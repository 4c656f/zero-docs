---
title: Supported Postgres Features
---

## Object Types

- Tables are synced
- Views are not synced
- Generated columns are not synced
- Indexes aren’t *synced* per-se but we do default to adding indexes to the replica that match the upstream indexes. In the future this will be customizable.

## Column Names

Currently Zero syncs column names exactly as they appear in Postgres. There is no ability to map column names from i.e., `FULL_NAME` in Postgres to `fullName` in TypeScript.

<Note type="warning">
  <aside>
    Another important caveat to be aware of is that in Postgres, column names are by default implicitly folded to lowercase. So if you do `CREATE TABLE person (fullName TEXT)` the actual column name in the database will end up as `fullname`. To avoid this terrible behavior you need to wrap your column names in double quotes when you define them, like `CREATE TABLE person ("fullName" TEXT)`.
  </aside>
</Note>

We will add column name mapping to Zero soon. See https://bugs.rocicorp.dev/issue/3106.

## Column Types

| Postgres Type | Type to put in `schema.ts` | Resulting JS/TS Type |
| --- | --- | --- |
| All numeric types | `number` | `number` |
| `char`, `varchar`, `text` | `string` | `string` |
| `bool` | `boolean` | `boolean` |
| `date`, `timestamp` | `number` | `number` |
| `json`, `jsonb` | `json` | `JSONValue` |

Other Postgres column types aren’t supported. They will be ignored when replicating (the synced data will be missing that column) and you will get a warning when `zero-cache` starts up.

If your schema has a pg type not listed here, you can support it in Zero by using a trigger to map it to some type that Zero can support. For example if you have an [enum type](https://www.postgresql.org/docs/current/datatype-enum.html#DATATYPE-ENUM) `Mood` used by column `user_mood mood`, you can use a trigger to map it to a `user_mood_text text` column. You would then use another trigger to map changes to `user_mood_text` back to `user_mood` so that the data can be updated by Zero.

Let us know if the lack of a particular column type is hindering your use of Zero. It can likely be added.

## Column Defaults

Column defaults are allowed but are not replicated to the client. Nullable columns with a default will have the default `null` on the client instead. When the write makes it to the server, the default will be applied and the client will see it.

The combined effect is essentially that column defaults work but are non-optimistic.

## Primary Keys

It is strongly recommended that primary keys be client-generated GUID-style values.

This makes optimistic creation and updates much easier. We most often use [`nanoid`](https://github.com/ai/nanoid) in our own applications.

<Note type="note">
  <aside>
    <h3>Why are GUID-style IDs easier?</h3>

    Imagine that the PK of your table is an auto-incrementing integer. If you optimistically create an entity of this type, you will have to give it some ID – the type will require it locally, but also if you want to optimistically creation relations against this row you’ll need an ID.

    You could sync the highest value seen for that table, but in race conditions it is possible for that ID to be taken by the time the creation makes it to the server. Your database can resolve this and assign the next ID, but now the relations you created optimistically will be against the wrong row. Blech.

    GUIDs makes a lot more sense in local-first applications.

    If your table has a natural key you can use that and it has less problems. But there is still the chance for a conflict. Imagine you are modeling orgs and you choose domainName as the natural key. It is possible for a race to happen and when the creation gets to the server, somebody has already chosen that domain name. In that case, the best thing to do is reject the write and show the user an error.
  </aside>
</Note>

If you want to have a short auto-incrementing numeric ID for ux reasons (ie, a bug number), that is possible – See [Demo Video](https://discord.com/channels/830183651022471199/1288232858795769917/1298114323272568852)!

Multi-column primary keys are supported (as is common in many:many relationships). But foreign keys must point to a single column on both side of the join.

## Limiting Replication

You can use [Permissions](https://www.notion.so/12b3bed8954580a89a6fcce72ab4c26a?pvs=21) to limit tables from replicating to Zero. In the near future you’ll also be able to use Permissions to limit individual columns.

Until then, a workaround is to use the Postgres [*publication*](https://www.postgresql.org/docs/current/sql-createpublication.html) feature to control the tables and columns that are replicated into `zero-cache`.

In your pg schema setup, create a Postgres `publication` with the tables and columns you want: `CREATE PUBLICATION zero_data FOR TABLE users (col1, col2, col3, ...), issues, comments` . If no such publication is present, Zero defaults to creating a publication that publishes the entire public schema.

## Self-Referential Relationships

Tables with relationships to themselves (i.e., `comment` that can have a parent `comment` ) are supported with two caveats:

1. Our `related` syntax has no sense of recursion, so you need to define your query manually to whatever level of depth you want. This actually ends up often being what you want – to get just a few levels of the tree at a time.
2. Our `createTableSchema` helper can’t deal with recursive types, so you have to first define the object outside `createTableSchema` then pass it as an arg, like so:
    
    ```tsx
    const foo = {
      tableName: 'issue',
      columns: {
        id: {type: 'string'},
        title: {type: 'string'},
      },
      primaryKey: ['id'],
      relationships: {
        self: {
          source: 'id',
          dest: {
            field: 'id',
            schema: () => issueSchema,
          },
        },
      },
    } as const;
    const issueSchema = createTableSchema(foo);
    ```
    
    See also https://bugs.rocicorp.dev/issue/3103.