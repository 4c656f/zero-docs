---
title: Schema Management
---

Zero has first-class support for controlled schema management and migration.

## Demo

<Note type="warning">
  <aside>
    TO DO: Embed video
  </aside>
</Note>

## Zero Schema

Zero applications have both a *database schema* (the normal backend database schema that today’s apps have) and a *Zero schema*. The two schemas are related, but not the same:

- The Zero schema is usually a subset of the server-side schema. It only needs to includes the tables and columns that the app actually uses.
- The Zero schema includes *authorization rules* that control access to the database.
- The Zero schema includes *relationships* that explicitly define how entities are related to each other.
- In order to support smooth schema migration, the two schemas don’t change in lockstep. Typically the database schema is changed first, then the Zero schema is changed later.

### Defining the Zero Schema

The Zero schema is encoded in a `schema.ts` file. See, for example,  [the schema file for`hello-zero`](https://github.com/rocicorp/hello-zero/blob/main/src/schema.ts).

### Table Schemas

Use the `createTableSchema` helper to define each table in your Zero schema:

```tsx
import { createTableSchema, } from "@rocicorp/zero";

const userSchema = createTableSchema({
  tableName: "user",
  columns: {
    id: { type: "string" },
    name: { type: "string" },
    partner: { type: "boolean" },
  },
  primaryKey: ["id"],
  relationships: {},
});
```

Columns can have the types `boolean`, `number`, `string`, `null`, `json`. See [Column Types](https://www.notion.so/Column-Types-12b3bed8954581daa5ecd5ca2160769d?pvs=21) for how database types are mapped to these types.

<Note type="warning">
  <aside>
    Currently, if the database type doesn’t map correctly to the Zero type, replication will continue and silently be wrong. This is a bug – in the future, this will be an error. See https://bugs.rocicorp.dev/issue/3112.
  </aside>
</Note>

### Optional Columns

Columns can be marked *optional*. This corresponds to the SQL concept `nullable`.

```tsx
const userSchema = createTableSchema({
  tableName: "user",
  columns: {
    id: { type: "string" },
    name: { type: "string" },
    nickName: { type: "string", optional: true },
  },
  primaryKey: ["id"],
  relationships: {},
});
```

An optional column can have a value of the specified type or `null` to mean *no value*.

<Note type="note">
  <aside>
    Note that `null` and `undefined` mean different things when working with Zero rows.

    - When reading, if a column is `optional`, Zero can return `null` for that field. `undefined` is not used at all when Reading from Zero.
    - When writing, you can specify `null` for an optional field to explicitly write `null` to the datastore, unsetting any previous value.
    - For `create` and `upsert` you can set optional fields to `undefined` (or leave the field off completely) to take the default value as specified by backend schema for that column. For `update` you can set any non-PK field to `undefined` to leave the previous value unmodified.
  </aside>
</Note>

### Database Schemas

Use `createSchema` to define the entire Zero schema:

```tsx
import { createSchema } from "@rocicorp/zero";

export const schema = createSchema({
  version: 1,
  tables: {
    user: userSchema,
    medium: mediumSchema,
    message: messageSchema,
  },
});
```

The `version` field is used as part of schema migration (see below).

## Migration Overview

When `zero-cache` first runs against your upstream Postgres database it adds a `schemaVersions` table to the `zero` schema:

```sql
\d zero."schemaVersions"
+---------------------+---------+------------------------+
| Column              | Type    | Modifiers              |
|---------------------+---------+------------------------|
| minSupportedVersion | integer |                        |
| maxSupportedVersion | integer |                        |
| lock                | boolean |  not null default true |
+---------------------+---------+------------------------+

> select * from zero."schemaVersions";
+---------------------+---------------------+------+
| minSupportedVersion | maxSupportedVersion | lock |
|---------------------+---------------------+------|
| 1                   | 1                   | True |
+---------------------+---------------------+------+
```

This table only ever has one row in it, and the two values represent the the range of schema versions currently supported by the database.

The client `schema` also has a `version` field:

```tsx
export const schema = createSchema({
  version: 1,
  tables: {
    user: userSchema,
  },
});
```

The `zero.schemaVersions` table is intended to be updated as part of your existing schema migration process.

## General Schema Change Process

Like other database-backed applications, Zero schema migration generally follow an “expand/migrate/contract” pattern:

- Determine the `schemaVersion` to use for this schema change, lets call it `N`.
- Implement and run an “expand” migration on the backend that is backwards compatible with existing schemas.  Add new rows, tables, as well as any defaults and triggers needed for backwards compatibility.  At the same time update the `maxSupportedVersion` to `N`.
- Update and deploy the client app.
    - Update its `schema` and `schemaVersion.`
    - Update app to use new `schema`.
- Optionally, after some grace period, implement and run a “contract” migration on the backend, deleting any obsolete rows/tables, at the same time update the `minSupportedVersion` to `N`.