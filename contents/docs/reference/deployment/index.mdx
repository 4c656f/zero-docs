---
title: Deploying Zero
---

To deploy a Zero app, you need to:

1. Deploy your backend database. Most standard Postgres hosts can be used with Zero. See [Connecting to Postgres](connecting-to-postgres) for details.
1. Deploy `zero-cache`. We provide a [Docker image](https://hub.docker.com/r/rocicorp/zero) for this that can be deployed to any standard Docker host.
1. Deploy your frontend. You can use any hosting service like Vercel or Netlify.

## Scalability

Currently `zero-cache` is single-node. This pains us as much as it does you ðŸ˜….

A single node can handle a fairly large number of concurrent users â€“ hundreds to thousands depending on what they're doing. But it's not infinitely scalable and updating `zero-cache` will take down your service for a minute or so while the Docker container restarts.

In the near future, Zero will be horizontally scalable, with features like rolling upates, sharding different subsets of data into different `zero-cache` instances, and geographic replication. See [Roadmap](roadmap) for more information.

## Topology

While `zero-cache` is single-node, you should deploy it close to your database to minimize sync latency. In the future, you will be able to deploy `zero-cache` in multiple regions to provide low-latency access to users around the world.

## Configuring `zero-cache`

The `zero-cache` image is configured via environment variables. See [zero-cache Config](./zero-cache-config) for available options.

## Deploying `zero-schema.json`

`zero-cache` must know about your [Client-Side Schema](schema-management) because it is used to enforce permissions. You can deploy it as a plain file, using `ZERO_SCHEMA_FILE`. For convenience, we also support deploying it as an environment variable, using `ZERO_SCHEMA_JSON`.

## Example â€“ Deploying to Fly.io

In this example, we'll deploy the [Quickstart](../welcome/quickstart) app to Fly.io. We'll use Fly.io for both the database and `zero-cache`.

### 1. Setup Quickstart

Go through the [Quickstart](../welcome/quickstart) guide to get the app running locally.

### 2. Setup Fly.io

Create an account on Fly.io and [install the Fly CLI](https://fly.io/docs/flyctl/install/).

### 3. Create Fly.io apps

<Note type="warning">
  <aside>
    **Note:** Fly.io requires app names to be unique across all Fly.io users. Change the `INITIALS` environment variable below to something unique.
  </aside>
</Note>

Create app for Postgres:

```bash
# Set this to your own initials or something unique to avoid conflicts with
# others following these instructions.
INITIALS=aa
PG_APP_NAME=$INITIALS-zstart-pg

# Generates a random password
PG_PASSWORD=$(head -c 1024 /dev/urandom | sha1sum | head -c 16)

fly postgres create \
  --name $PG_APP_NAME \
  --region lax \
  --initial-cluster-size 1 \
  --vm-size shared-cpu-2x \
  --volume-size 40 \
  --password=$PG_PASSWORD
```

### Assign a V4 IP Address to the Database

This isn't strictly necessary, and costs a small amount of money, but it makes it easier to test because you can connect from your local machine.

```bash
fly ips allocate-v4 --app $PG_APP_NAME
```

### Seed Upstream database

```bash
CONNECTION_STRING="postgres://postgres:$PG_PASSWORD@$PG_APP_NAME.fly.dev:5432"

# Seed database
psql -f docker/seed.sql $CONNECTION_STRING

# Set wal_level to logical to support replication to zero-cache
psql -c "ALTER SYSTEM SET wal_level = logical;" $CONNECTION_STRING

# Restart Postgres to apply change to wal_level
fly postgres restart --app $PG_APP_NAME

# Ensure wal level was changed - should output `logical`
psql -c "show wal_level;" $CONNECTION_STRING
```

### Run local zero-cache against remote Postgres

Update the `.env` file with the remote Postgres on Fly.io.

```bash
cat <<EOF > .env
ZERO_UPSTREAM_DB="${CONNECTION_STRING}/zstart"
ZERO_CVR_DB="${CONNECTION_STRING}/zstart_cvr"
ZERO_CHANGE_DB="${CONNECTION_STRING}/zstart_cdb"
ZERO_JWT_SECRET=secretkey
ZERO_REPLICA_FILE=/tmp/zstart_replica.db
EOF
```

Restart zero-cache:

```bash
# Clear the replica since we're changing the upstream database.
rm /tmp/zstart_replica.db*

npx zero-cache
```

The app should run again, but sync will be much slower because zero-cache and Postgres are far from each other. Let's fix that by deploying `zero-cache` to Fly.io too.

### Create `zero-cache` Fly.io app

```bash
CACHE_APP_NAME=$INITIALS-zstart-cache
fly app create $CACHE_APP_NAME
```

### Publish zero-cache

Create a `fly.toml` file. We'll copy the `zero-schema.json` into the toml file to pass it to the server as an environment variable.

```bash
cat <<EOF > fly.toml
app = "$CACHE_APP_NAME"
primary_region = 'lax'

[build]
image = "registry.hub.docker.com/rocicorp/zero:latest"

[http_service]
internal_port = 4848
force_https = true
auto_stop_machines = 'off'
min_machines_running = 1

[[http_service.checks]]
grace_period = "10s"
interval = "30s"
method = "GET"
timeout = "5s"
path = "/"

[[vm]]
memory = '2gb'
cpu_kind = 'shared'
cpus = 2

[mounts]
source = "sqlite_db"
destination = "/data"

[env]
ZERO_REPLICA_FILE = "/data/sync-replica.db"
ZERO_UPSTREAM_DB="${CONNECTION_STRING}/zstart"
ZERO_CVR_DB="${CONNECTION_STRING}/zstart_cvr"
ZERO_CHANGE_DB="${CONNECTION_STRING}/zstart_cdb"
ZERO_JWT_SECRET="secretkey"
LOG_LEVEL = "debug"
ZERO_SCHEMA_JSON = """$(cat zero-schema.json)"""
EOF
```

Then publish `zero-cache`:

```bash
fly deploy
```

### Update App to Connect to Remote `zero-cache`

```bash
cat <<EOF > .env.local
VITE_PUBLIC_SERVER='https://${CACHE_APP_NAME}.fly.dev/'
EOF
```

Now refresh the app and it should be fast again. Open the web inspector to verify the app is talking to the remote `zero-cache`!

